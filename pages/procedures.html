<!-- ===== Procedures Component (Drop-in) ===== -->
<div/procedures.json
  <!-- Controls -->
  <div class="rsaControls">
    <label>
      Heading:
      <select data-role="heading">
        <option value="__ALL__">All headings</option>
      </select>
    </label>

    <label>
      Subheading:
      <select data-role="subheading" disabled>
        <option value="__ALL__">All subheadings</option>
      </select>
    </label>

    <label>
      <input type="checkbox" data-role="mandatory"> Mandatory only
    </label>

    <label>
      Search:
      <input type="text" data-role="search" placeholder="Search within text…">
    </label>

    <button type="button" data-role="clear">Clear</button>
  </div>

  <!-- Results will render here -->
  <div data-role="results"><div class="loading">Loading…</div></div>

  <!-- Optional inline fallback (uncomment to test without fetching)
  <script id="proceduresData" type="application/json">
  [
    {"paraNo":"TEST","heading":"Debug","subheading":"Inline","text":"If you can see this, fetch/path is the problem.","mandatory":false}
  ]
  </script>
  -->
</div>

<script>
/* ===================================================================
   procedures.js (inline) — fully self-contained, robust loader + UI
   =================================================================== */

/* ---------- Fallback helpers (use yours if present) ---------- */
if (typeof escapeHtml !== 'function') {
  window.escapeHtml = (s) => String(s)
    .replaceAll('&', '&amp;')
    .replaceAll('<', '&lt;')
    .replaceAll('>', '&gt;')
    .replaceAll('"', '&quot;')
    .replaceAll("'", '&#039;');
}
if (typeof escapeAttr !== 'function') window.escapeAttr = window.escapeHtml;
if (typeof pickField !== 'function') {
  window.pickField = function pickField(obj, ...names) {
    if (!obj || typeof obj !== 'object') return undefined;
    const keys = Object.keys(obj);
    for (const name of names) {
      if (obj[name] != null) return obj[name];
      const k = keys.find(k => k.toLowerCase() === name.toLowerCase());
      if (k && obj[k] != null) return obj[k];
    }
    return undefined;
  };
}

/* ---------- Utilities ---------- */
const naturalCompare = (a, b) => String(a).localeCompare(String(b), undefined, { numeric: true, sensitivity: 'base' });
const dedupe = arr => Array.from(new Set(arr || []));

function toBool(val) {
  if (typeof val === 'boolean') return val;
  if (val == null) return null;
  const s = String(val).trim().toLowerCase();
  if (['true','yes','y','1'].includes(s)) return true;
  if (['false','no','n','0'].includes(s)) return false;
  return null;
}

// Allow <u> while escaping everything else
function safeHtmlWithUnderline(s) {
  const PH_OPEN = '___OPEN_U___';
  const PH_CLOSE = '___CLOSE_U___';
  const src = String(s || '').replaceAll('<u>', PH_OPEN).replaceAll('</u>', PH_CLOSE);
  const esc = escapeHtml(src);
  return esc.replaceAll(PH_OPEN, '<u>').replaceAll(PH_CLOSE, '</u>');
}

// Split to lead + bullets (•, -, 1) or 1.)
function splitLeadAndBullets(text) {
  const lines = String(text || '').split(/\r?\n/).map(l => l.trim()).filter(Boolean);
  if (lines.length === 0) return { lead: '', bullets: [] };
  const lead = lines[0];
  const bullets = [];
  for (let i = 1; i < lines.length; i++) {
    const ln = lines[i];
    const m = ln.match(/^([•\-]|\d+[\)\.])\s*(.*)$/);
    if (m) bullets.push(m[2] || '');
    else if (bullets.length) bullets[bullets.length - 1] += ' ' + ln;
    else bullets.push(ln);
  }
  return { lead, bullets };
}

/* ---------- Robust JSON normaliser ---------- */
function unwrapArrayish(obj) {
  if (Array.isArray(obj)) return obj;

  if (obj && typeof obj === 'object') {
    for (const key of ['records','items','data','value','values','rows']) {
      if (Array.isArray(obj[key])) return obj[key];
      if (obj[key] && typeof obj[key] === 'object' && !Array.isArray(obj[key])) {
        const vals = Object.values(obj[key]);
        if (vals.length && typeof vals[0] === 'object') return vals;
      }
    }
    const arrayProp = Object.entries(obj).find(([, v]) => Array.isArray(v));
    if (arrayProp) return arrayProp[1];

    const vals = Object.values(obj);
    if (vals.length && vals.every(v => v && typeof v === 'object' && !Array.isArray(v))) {
      return vals;
    }
  }
  return [];
}

function normalizeProcedures(input) {
  const raw = unwrapArrayish(input);
  const out = [];
  for (const r of raw) {
    out.push({
      paraNo: String(pickField(r, 'paraNo','Paragraph No','para','id') ?? '').trim(),
      heading: String(pickField(r, 'heading','Heading') ?? '').trim(),
      subheading: String(pickField(r, 'subheading','Subheading','section') ?? '').trim(),
      text: String(pickField(r, 'text','Paragraph Text','content') ?? ''),
      mandatory: toBool(pickField(r, 'mandatory','Mandatory (Boxed)','isMandatory'))
    });
  }
  return out;
}

/* ---------- Rendering ---------- */
function renderMandatory(rec) {
  // EXACT structure you requested
  const { lead, bullets } = splitLeadAndBullets(rec.text);
  const wrapper = document.createElement('div');
  wrapper.className = 'mandatoryDiv';
  wrapper.setAttribute('data-para', rec.paraNo);

  const leadDiv = document.createElement('div');
  leadDiv.innerHTML = safeHtmlWithUnderline(lead);
  wrapper.appendChild(leadDiv);

  if (bullets.length) {
    const ul = document.createElement('ul');
    for (const b of bullets) {
      const li = document.createElement('li');
      li.innerHTML = safeHtmlWithUnderline(b);
      ul.appendChild(li);
    }
    wrapper.appendChild(ul);
  }
  return wrapper;
}

function renderNormal(rec) {
  const div = document.createElement('div');
  div.className = 'comment';
  div.setAttribute('data-para', rec.paraNo);
  div.innerHTML = safeHtmlWithUnderline(rec.text).replace(/\n/g, '<br>');
  return div;
}

function renderResults(records, container) {
  container.innerHTML = '';
  if (!records.length) {
    container.innerHTML = '<div class="emptyState">No results match your filters.</div>';
    return;
  }

  // Group by heading -> subheading
  const byHeading = new Map();
  for (const r of records) {
    if (!byHeading.has(r.heading)) byHeading.set(r.heading, new Map());
    const bySub = byHeading.get(r.heading);
    if (!bySub.has(r.subheading)) bySub.set(r.subheading, []);
    bySub.get(r.subheading).push(r);
  }

  const headings = Array.from(byHeading.keys()).sort(naturalCompare);
  for (const h of headings) {
    const hEl = document.createElement('h2');
    hEl.className = 'rsaHeading';
    hEl.textContent = h;
    container.appendChild(hEl);

    const bySub = byHeading.get(h);
    const subs = Array.from(bySub.keys()).sort(naturalCompare);
    for (const s of subs) {
      const sEl = document.createElement('h3');
      sEl.className = 'rsaSubheading';
      sEl.textContent = s;
      container.appendChild(sEl);

      for (const rec of bySub.get(s)) {
        const node = rec.mandatory ? renderMandatory(rec) : renderNormal(rec);
        container.appendChild(node);
      }
    }
  }
}

/* ---------- UI wiring ---------- */
function populateHeadingDropdown(data, selHeading, selSubheading) {
  const headings = dedupe(data.map(d => d.heading)).sort(naturalCompare);
  selHeading.innerHTML = '<option value="__ALL__">All headings</option>' +
    headings.map(h => `<option value="${escapeAttr(h)}">${escapeHtml(h)}</option>`).join('');
  selSubheading.innerHTML = '<option value="__ALL__">All subheadings</option>';
  selSubheading.disabled = true;
}

function populateSubheadingDropdown(data, currentHeading, selSubheading) {
  let subs;
  if (currentHeading && currentHeading !== '__ALL__') {
    subs = dedupe(data.filter(d => d.heading === currentHeading).map(d => d.subheading)).sort(naturalCompare);
    selSubheading.disabled = false;
  } else {
    subs = dedupe(data.map(d => d.subheading)).sort(naturalCompare);
    selSubheading.disabled = true;
  }
  selSubheading.innerHTML = '<option value="__ALL__">All subheadings</option>' +
    subs.map(s => `<option value="${escapeAttr(s)}">${escapeHtml(s)}</option>`).join('');
}

function applyFiltersAndRender({ data, els }) {
  const h = els.heading.value;
  const s = els.subheading.value;
  const mandOnly = els.mandatory.checked;
  const q = els.search.value.trim().toLowerCase();

  let filtered = data.slice();
  if (h !== '__ALL__') filtered = filtered.filter(r => r.heading === h);
  if (s !== '__ALL__' && !els.subheading.disabled) filtered = filtered.filter(r => r.subheading === s);
  if (mandOnly) filtered = filtered.filter(r => r.mandatory === true);
  if (q) {
    const terms = q.split(/\s+/).filter(Boolean);
    filtered = filtered.filter(r => {
      const t = (r.text || '').toLowerCase();
      return terms.every(term => t.includes(term));
    });
  }
  renderResults(filtered, els.results);
}

function clearFilters({ data, els }) {
  els.heading.value = '__ALL__';
  populateSubheadingDropdown(data, '__ALL__', els.subheading);
  els.mandatory.checked = false;
  els.search.value = '';
  applyFiltersAndRender({ data, els });
}

/* ---------- Loader with inline fallback ---------- */
async function loadProcedures(root) {
  // Optional inline fallback
  const inline = root.querySelector('#proceduresData');
  if (inline) {
    try {
      const inlineJson = JSON.parse(inline.textContent || '[]');
      return normalizeProcedures(inlineJson);
    } catch (e) { console.warn('Inline proceduresData invalid JSON; will fetch.'); }
  }

  // Fetch from data-src or default path
  const url = root.dataset && root.dataset.src ? root.dataset.src : 'data/procedures.json';
  const res = await fetch(url, { cache: 'no-store' });
  if (!res.ok) throw new Error(`HTTP ${res.status} fetching ${url}`);
  const json = await res.json();
  return normalizeProcedures(json);
}

/* ---------- Flexible element resolution ---------- */
function findWithin(root, fallbackId, ...selectors) {
  for (const sel of selectors) {
    const el = root.querySelector(sel);
    if (el) return el;
  }
  if (fallbackId) {
    const byId = document.getElementById(fallbackId);
    if (byId) return byId;
  }
  return null;
}
function listMissing(els) {
  return Object.entries(els).filter(([, el]) => !el).map(([k]) => k);
}

/* ---------- Boot with root wait (covers SPA/lazy mounts) ---------- */
function initProceduresUI() {
  const root = document.getElementById('proceduresApp') ||
               document.querySelector('[data-procedures-root]');
  if (!root) {
    console.warn('procedures.js: missing root (#proceduresApp or [data-procedures-root])');
    return;
  }

  const els = {
    heading:    findWithin(root, 'procHeading',    '[data-role="heading"]',    '#procHeading'),
    subheading: findWithin(root, 'procSubheading', '[data-role="subheading"]', '#procSubheading'),
    mandatory:  findWithin(root, 'procMandatory',  '[data-role="mandatory"]',  '#procMandatory', 'input[type="checkbox"][name="mandatory"]'),
    search:     findWithin(root, 'procSearch',     '[data-role="search"]',     '#procSearch', 'input[type="search"][name="search"]'),
    clear:      findWithin(root, 'procClear',      '[data-role="clear"]',      '#procClear', 'button[name="clear"]'),
    results:    findWithin(root, 'procResults',    '[data-role="results"]',    '#procResults')
  };

  const missing = listMissing(els);
  if (missing.length) {
    console.warn('procedures.js: missing expected DOM nodes:', missing);
    return;
  }

  // Debounced search
  let typingTimer = 0;
  els.search.addEventListener('input', () => {
    clearTimeout(typingTimer);
    typingTimer = setTimeout(() => applyFiltersAndRender({ data: window.PROC_DATA, els }), 200);
  });
  els.heading.addEventListener('change', () => {
    populateSubheadingDropdown(window.PROC_DATA, els.heading.value, els.subheading);
    applyFiltersAndRender({ data: window.PROC_DATA, els });
  });
  els.subheading.addEventListener('change', () => applyFiltersAndRender({ data: window.PROC_DATA, els }));
  els.mandatory.addEventListener('change', () => applyFiltersAndRender({ data: window.PROC_DATA, els }));
  els.clear.addEventListener('click', () => clearFilters({ data: window.PROC_DATA, els }));

  els.results.innerHTML = '<div class="loading">Loading…</div>';

  loadProcedures(root)
    .then(data => {
      window.PROC_DATA = data;
      window.PROC_READY = true;

      console.log(`Procedures loaded: ${data.length}`);
      console.table(data.slice(0, 10));

      if (!data.length) {
        els.results.innerHTML = '<div class="error">Loaded 0 rows. Check JSON shape/fields.</div>';
        return;
      }

      populateHeadingDropdown(data, els.heading, els.subheading);
      populateSubheadingDropdown(data, '__ALL__', els.subheading);
      applyFiltersAndRender({ data, els });
    })
    .catch(err => {
      window.PROC_READY = true;
      console.error('Failed to load procedures:', err);
      const src = root.dataset && root.dataset.src ? root.dataset.src : 'data/procedures.json';
      els.results.innerHTML = `<div class="error">Failed to load: ${escapeHtml(err.message)}<br><small>Path checked: ${escapeHtml(src)}</small></div>`;
    });
}

// Wait for root (covers async injection)
(function waitForRoot(selector = '#proceduresApp,[data-procedures-root]', timeoutMs = 5000) {
  const start = Date.now();
  (function tick() {
    const root = document.querySelector(selector);
    if (root) { initProceduresUI(); return; }
    if (Date.now() - start > timeoutMs) {
      console.warn('procedures.js: root not found before timeout:', selector);
      return;
    }
    setTimeout(tick, 100);
  })();
})();
</script>

<!-- Skeleton class hooks (no visual styles; add your CSS later) -->
<style>
  #proceduresApp { display:block; }
  .rsaControls { display:flex; gap:1rem; align-items:center; flex-wrap:wrap; margin-bottom:1rem; }
  .rsaHeading { /* style me */ }
  .rsaSubheading { /* style me */ }
  .comment { margin: 0.5rem 0 1rem 0; }
  .mandatoryDiv { border: 2px solid #e0a800; padding: 0.5rem 0.75rem; border-radius: 4px; background: #fff8e1; }
  .loading, .emptyState, .error { margin: 0.75rem 0; }
</style>
