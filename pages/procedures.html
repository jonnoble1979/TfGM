<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Procedures Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    /* ---- Skeleton styling (add your design later) ---- */
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; line-height: 1.45; margin: 0; padding: 1rem; }
    .rsaControls { display: flex; gap: 1rem; row-gap: .5rem; align-items: center; flex-wrap: wrap; margin-bottom: 1rem; }
    .rsaControls label { display: inline-flex; gap: .5rem; align-items: center; }
    .rsaControls select, .rsaControls input[type="text"] { padding: .35rem .5rem; }
    .rsaControls button { padding: .4rem .7rem; }

    .rsaHeading { margin: 1.25rem 0 .25rem; font-size: 1.35rem; font-weight: 700; }
    .rsaSubheading { margin: .5rem 0 .25rem; font-size: 1.1rem; font-weight: 650; }

    .comment { margin: .25rem 0 .9rem 0; }
    .mandatoryDiv { border: 2px solid #e0a800; padding: .55rem .75rem; border-radius: 6px; background: #fff8e1; margin: .25rem 0 .9rem 0; }
    .mandatoryDiv ul { margin: .5rem 0 0 1rem; }
    .mandatoryDiv li { margin: .2rem 0; }

    .loading, .emptyState, .error { margin: .75rem 0; }
    .sr-only { position: absolute; left: -9999px; width: 1px; height: 1px; overflow: hidden; }
  </style>
</head>
<body>

  <!-- ===== Procedures Component ===== -->
  <!-- This absolute path matches your structure: /index.html and /data/procedures.json -->
  <div id="proceds.json
    <div class="rsaControls" role="region" aria-label="Filters">
      <label for="procHeading">
        Heading:
        <select id="procHeading" data-role="heading" aria-label="Filter by heading">
          <option value="__ALL__">All headings</option>
        </select>
      </label>

      <label for="procSubheading">
        Subheading:
        <select id="procSubheading" data-role="subheading" aria-label="Filter by subheading" disabled>
          <option value="__ALL__">All subheadings</option>
        </select>
      </label>

      <label for="procMandatory">
        <input type="checkbox" id="procMandatory" data-role="mandatory" />
        Mandatory only
      </label>

      <label for="procSearch">
        Search:
        <input type="text" id="procSearch" data-role="search" placeholder="Search within text…" inputmode="search" />
      </label>

      <button type="button" id="procClear" data-role="clear" aria-label="Clear filters">Clear</button>
    </div>

    <div id="procResults" data-role="results">
      <div class="loading">Loading…</div>
    </div>

    <!-- Optional inline fallback (uncomment to test without fetching)
    <script id="proceduresData" type="application/json">
    [
      {"paraNo":"1.1.1","heading":"Introduction","subheading":"Purpose","text":"Inline test record.","mandatory":false}
    ]
    </script>
    -->
  </div>

  <noscript>
    <p class="error">JavaScript is required to view procedures.</p>
  </noscript>

  <script>
    /* ===================================================================
       procedures.js — self-contained, robust loader + UI
       =================================================================== */

    /* ---------- Fallback helpers (use your own if already on page) ---------- */
    if (typeof window.escapeHtml !== 'function') {
      window.escapeHtml = (s) => String(s)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#039;');
    }
    if (typeof window.escapeAttr !== 'function') window.escapeAttr = window.escapeHtml;
    if (typeof window.pickField !== 'function') {
      window.pickField = function pickField(obj, ...names) {
        if (!obj || typeof obj !== 'object') return undefined;
        const keys = Object.keys(obj);
        for (const name of names) {
          if (obj[name] != null) return obj[name];
          const k = keys.find(k => k.toLowerCase() === name.toLowerCase());
          if (k && obj[k] != null) return obj[k];
        }
        return undefined;
      };
    }

    /* ---------- Utilities ---------- */
    const naturalCompare = (a, b) => String(a).localeCompare(String(b), undefined, { numeric: true, sensitivity: 'base' });
    const dedupe = arr => Array.from(new Set(arr || []));

    function toBool(val) {
      if (typeof val === 'boolean') return val;
      if (val == null) return null;
      const s = String(val).trim().toLowerCase();
      if (['true','yes','y','1'].includes(s)) return true;
      if (['false','no','n','0'].includes(s)) return false;
      return null;
    }

    // Allow <u> while escaping everything else
    function safeHtmlWithUnderline(s) {
      const PH_OPEN = '___OPEN_U___';
      const PH_CLOSE = '___CLOSE_U___';
      const src = String(s || '').replaceAll('<u>', PH_OPEN).replaceAll('</u>', PH_CLOSE);
      const esc = escapeHtml(src);
      return esc.replaceAll(PH_OPEN, '<u>').replaceAll(PH_CLOSE, '</u>');
    }

    // Split text to lead + bullets (•, -, 1) or 1.)
    function splitLeadAndBullets(text) {
      const lines = String(text || '').split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      if (lines.length === 0) return { lead: '', bullets: [] };
      const lead = lines[0];
      const bullets = [];
      for (let i = 1; i < lines.length; i++) {
        const ln = lines[i];
        const m = ln.match(/^([•\-]|\d+[\)\.])\s*(.*)$/);
        if (m) bullets.push(m[2] || '');
        else if (bullets.length) bullets[bullets.length - 1] += ' ' + ln;
        else bullets.push(ln);
      }
      return { lead, bullets };
    }

    /* ---------- Robust JSON normaliser ---------- */
    function unwrapArrayish(obj) {
      if (Array.isArray(obj)) return obj;

      if (obj && typeof obj === 'object') {
        for (const key of ['records','items','data','value','values','rows']) {
          if (Array.isArray(obj[key])) return obj[key];
          if (obj[key] && typeof obj[key] === 'object' && !Array.isArray(obj[key])) {
            const vals = Object.values(obj[key]);
            if (vals.length && typeof vals[0] === 'object') return vals;
          }
        }
        const arrayProp = Object.entries(obj).find(([, v]) => Array.isArray(v));
        if (arrayProp) return arrayProp[1];

        const vals = Object.values(obj);
        if (vals.length && vals.every(v => v && typeof v === 'object' && !Array.isArray(v))) {
          return vals;
        }
      }
      return [];
    }

    function normalizeProcedures(input) {
      const raw = unwrapArrayish(input);
      const out = [];
      for (const r of raw) {
        out.push({
          paraNo: String(pickField(r, 'paraNo','Paragraph No','para','id') ?? '').trim(),
          heading: String(pickField(r, 'heading','Heading') ?? '').trim(),
          subheading: String(pickField(r, 'subheading','Subheading','section') ?? '').trim(),
          text: String(pickField(r, 'text','Paragraph Text','content') ?? ''),
          mandatory: toBool(pickField(r, 'mandatory','Mandatory (Boxed)','isMandatory'))
        });
      }
      return out;
    }

    /* ---------- Rendering ---------- */
    function renderMandatory(rec) {
      // EXACT structure you specified:
      // <div class="mandatoryDiv">
      //   <div>Lead sentence…</div>
      //   <ul><li>bullet…</li>…</ul>
      // </div>
      const { lead, bullets } = splitLeadAndBullets(rec.text);
      const wrapper = document.createElement('div');
      wrapper.className = 'mandatoryDiv';
      wrapper.setAttribute('data-para', rec.paraNo);

      const leadDiv = document.createElement('div');
      leadDiv.innerHTML = safeHtmlWithUnderline(lead);
      wrapper.appendChild(leadDiv);

      if (bullets.length) {
        const ul = document.createElement('ul');
        for (const b of bullets) {
          const li = document.createElement('li');
          li.innerHTML = safeHtmlWithUnderline(b);
          ul.appendChild(li);
        }
        wrapper.appendChild(ul);
      }
      return wrapper;
    }

    function renderNormal(rec) {
      const div = document.createElement('div');
      div.className = 'comment';
      div.setAttribute('data-para', rec.paraNo);
      div.innerHTML = safeHtmlWithUnderline(rec.text).replace(/\n/g, '<br>');
      return div;
    }

    function renderResults(records, container) {
      container.innerHTML = '';
      if (!records.length) {
        container.innerHTML = '<div class="emptyState">No results match your filters.</div>';
        return;
      }

      // Group by heading -> subheading
      const byHeading = new Map();
      for (const r of records) {
        if (!byHeading.has(r.heading)) byHeading.set(r.heading, new Map());
        const bySub = byHeading.get(r.heading);
        if (!bySub.has(r.subheading)) bySub.set(r.subheading, []);
        bySub.get(r.subheading).push(r);
      }

      const headings = Array.from(byHeading.keys()).sort(naturalCompare);
      for (const h of headings) {
        const hEl = document.createElement('h2');
        hEl.className = 'rsaHeading';
        hEl.textContent = h;
        container.appendChild(hEl);

        const bySub = byHeading.get(h);
        const subs = Array.from(bySub.keys()).sort(naturalCompare);
        for (const s of subs) {
          const sEl = document.createElement('h3');
          sEl.className = 'rsaSubheading';
          sEl.textContent = s;
          container.appendChild(sEl);

          for (const rec of bySub.get(s)) {
            const node = rec.mandatory ? renderMandatory(rec) : renderNormal(rec);
            container.appendChild(node);
          }
        }
      }
    }

    /* ---------- UI wiring ---------- */
    function populateHeadingDropdown(data, selHeading, selSubheading) {
      const headings = dedupe(data.map(d => d.heading)).sort(naturalCompare);
      selHeading.innerHTML = '<option value="__ALL__">All headings</option>' +
        headings.map(h => `<option value="${escapeAttr(h)}">${escapeHtml(h)}</option>`).join('');
      selSubheading.innerHTML = '<option value="__ALL__">All subheadings</option>';
      selSubheading.disabled = true;
    }

    function populateSubheadingDropdown(data, currentHeading, selSubheading) {
      let subs;
      if (currentHeading && currentHeading !== '__ALL__') {
        subs = dedupe(data.filter(d => d.heading === currentHeading).map(d => d.subheading)).sort(naturalCompare);
        selSubheading.disabled = false;
      } else {
        subs = dedupe(data.map(d => d.subheading)).sort(naturalCompare);
        selSubheading.disabled = true;
      }
      selSubheading.innerHTML = '<option value="__ALL__">All subheadings</option>' +
        subs.map(s => `<option value="${escapeAttr(s)}">${escapeHtml(s)}</option>`).join('');
    }

    function applyFiltersAndRender({ data, els }) {
      const h = els.heading.value;
      const s = els.subheading.value;
      const mandOnly = els.mandatory.checked;
      const q = els.search.value.trim().toLowerCase();

      let filtered = data.slice();
      if (h !== '__ALL__') filtered = filtered.filter(r => r.heading === h);
      if (s !== '__ALL__' && !els.subheading.disabled) filtered = filtered.filter(r => r.subheading === s);
      if (mandOnly) filtered = filtered.filter(r => r.mandatory === true);
      if (q) {
        const terms = q.split(/\s+/).filter(Boolean);
        filtered = filtered.filter(r => {
          const t = (r.text || '').toLowerCase();
          return terms.every(term => t.includes(term));
        });
      }
      renderResults(filtered, els.results);
    }

    function clearFilters({ data, els }) {
      els.heading.value = '__ALL__';
      populateSubheadingDropdown(data, '__ALL__', els.subheading);
      els.mandatory.checked = false;
      els.search.value = '';
      applyFiltersAndRender({ data, els });
    }

    /* ---------- Loader with inline fallback ---------- */
    async function loadProcedures(root) {
      // Try inline fallback first (optional)
      const inline = root.querySelector('#proceduresData');
      if (inline) {
        try {
          const inlineJson = JSON.parse(inline.textContent || '[]');
          return normalizeProcedures(inlineJson);
        } catch (e) {
          console.warn('Inline proceduresData invalid JSON; will fetch.');
        }
      }

      // Fetch from data-src or default
      const url = root.dataset && root.dataset.src ? root.dataset.src : 'data/procedures.json';
      const absUrl = new URL(url, document.baseURI).href; // resolve relative paths robustly
      console.log('Fetching procedures from:', absUrl);

      const res = await fetch(absUrl, { cache: 'no-store' });
      if (!res.ok) throw new Error(`HTTP ${res.status} fetching ${absUrl}`);
      const json = await res.json();
      return normalizeProcedures(json);
    }

    /* ---------- Flexible element resolution ---------- */
    function findWithin(root, ...selectors) {
      for (const sel of selectors) {
        const el = root.querySelector(sel);
        if (el) return el;
      }
      return null;
    }
    function listMissing(els) { return Object.entries(els).filter(([, el]) => !el).map(([k]) => k); }

    /* ---------- Init ---------- */
    function initProceduresUI() {
      const root = document.getElementById('proceduresApp') ||
                   document.querySelector('[data-procedures-root]');
      if (!root) {
        console.warn('procedures.js: missing root (#proceduresApp or [data-procedures-root])');
        return;
      }

      const els = {
        heading:    findWithin(root, '[data-role="heading"]',    '#procHeading'),
        subheading: findWithin(root, '[data-role="subheading"]', '#procSubheading'),
        mandatory:  findWithin(root, '[data-role="mandatory"]',  '#procMandatory', 'input[type="checkbox"][name="mandatory"]'),
        search:     findWithin(root, '[data-role="search"]',     '#procSearch'),
        clear:      findWithin(root, '[data-role="clear"]',      '#procClear'),
        results:    findWithin(root, '[data-role="results"]',    '#procResults')
      };

      const missing = listMissing(els);
      if (missing.length) {
        console.warn('procedures.js: missing expected DOM nodes:', missing);
        return;
      }

      // Debounced search
      let typingTimer = 0;
      els.search.addEventListener('input', () => {
        clearTimeout(typingTimer);
        typingTimer = setTimeout(() => applyFiltersAndRender({ data: window.PROC_DATA, els }), 200);
      });

      els.heading.addEventListener('change', () => {
        populateSubheadingDropdown(window.PROC_DATA, els.heading.value, els.subheading);
        applyFiltersAndRender({ data: window.PROC_DATA, els });
      });
      els.subheading.addEventListener('change', () => applyFiltersAndRender({ data: window.PROC_DATA, els }));
      els.mandatory.addEventListener('change', () => applyFiltersAndRender({ data: window.PROC_DATA, els }));
      els.clear.addEventListener('click', () => clearFilters({ data: window.PROC_DATA, els }));

      els.results.innerHTML = '<div class="loading">Loading…</div>';

      loadProcedures(root)
        .then(data => {
          window.PROC_DATA = data;
          window.PROC_READY = true;

          console.log(`Procedures loaded: ${data.length}`);
          console.table(data.slice(0, 10)); // sanity preview

          if (!data.length) {
            els.results.innerHTML = '<div class="error">Loaded 0 rows. Check JSON shape/fields.</div>';
            return;
          }

          populateHeadingDropdown(data, els.heading, els.subheading);
          populateSubheadingDropdown(data, '__ALL__', els.subheading);
          applyFiltersAndRender({ data, els });
        })
        .catch(err => {
          window.PROC_READY = true;
          console.error('Failed to load procedures:', err);
          const src = root.dataset && root.dataset.src ? root.dataset.src : 'data/procedures.json';
          els.results.innerHTML = `<div class="error">Failed to load: ${escapeHtml(err.message)}<br><small>Path checked: ${escapeHtml(src)}</small></div>`;
        });
    }

    // Boot
    document.addEventListener('DOMContentLoaded', initProceduresUI);
  </script>
</body>
</html>
