<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chevron Tabs — Canvas (flat start, correct left arrow, no duplicate labels)</title>
<style>
  :root{
    --h: 64;          /* strip height (px, preferably even to avoid subpixel blur) */
    --tip: 24;        /* tip width (px) */
    --tail: 14;       /* slanted tail width (px) on inner tabs’ left side */
    --left-cap: 10;   /* length of the flat horizontal start (px) on the very left */

    --brand-start:#2e7df6; /* active gradient start */
    --brand-end:  #7aa8ff; /* active gradient end */
    --hover:      #eaf2ff; /* hover fill for inactive segments */
    --text:       #0b1f33;
    --text-muted: #5a6b82;
    --body:       #f7f9fc;
    --box-border: #2e7df6;
  }

  html, body { margin:0; padding:0; background:var(--body);
    font:16px/1.5 system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif; }
  .wrap { max-width:1100px; margin:24px auto; padding:0 16px; }

  .tabs-shell{
    border:2px solid var(--box-border);
    border-radius:10px;
    background:#fff;
  }

  /* ---- Canvas-backed chevron strip (no seams) ---- */
  .chevron-strip{
    position:relative;
    height: calc(var(--h) * 1px);
    border-bottom:1px solid var(--box-border);
  }
  .chevron-strip canvas{
    display:block; width:100%; height:100%;
  }

  /* Transparent overlay buttons for click/keyboard; canvas handles the visuals */
  .labels{ position:absolute; inset:0; }
  .tab{
    position:absolute; top:0; height:100%;
    display:flex; align-items:center; justify-content:center;
    background:transparent; border:0; margin:0; padding:0;
    /* hide visible text to avoid duplication; use aria-label instead */
    color:transparent; font-size:0;
    cursor:pointer; outline:none;
  }
  .tab:focus-visible{ outline:3px solid #94b8ff; outline-offset:2px; }

  /* Panels */
  .panels{ background:var(--body); padding:16px; }
  .panel{ display:none; }
  .panel.active{ display:block; }
</style>
</head>
<body>
<div class="wrap">
  <h2>Road Safety Audit Stages — Canvas chevrons (flat start, no seams)</h2>

  <div class="tabs-shell" aria-label="RSA stages tabs">
    <div id="chevrons" class="chevron-strip" role="tablist">
      <canvas id="navCanvas"></canvas>
      <div id="labels" class="labels" aria-hidden="false"></div>
    </div>

    <div class="panels" id="panels">
      <section class="panel active" role="tabpanel" aria-labelledby="t0"><h3>Interim Road Safety Audit</h3><p>Interim content…</p></section>
      <section class="panel" role="tabpanel" aria-labelledby="t1"><h3>Stage 1 Road Safety Audit</h3><p>Stage 1 content…</p></section>
      <section class="panel" role="tabpanel" aria-labelledby="t2"><h3>Stage 2 &amp; Combined Stage 1–2</h3><p>Stage 2 + Combined content…</p></section>
      <section class="panel" role="tabpanel" aria-labelledby="t3"><h3>Stage 3 Road Safety Audit</h3><p>Stage 3 content…</p></section>
      <section class="panel" role="tabpanel" aria-labelledby="t4"><h3>Stage 4 Road Safety Audit</h3><p>Stage 4 content…</p></section>
    </div>
  </div>
</div>

<script>
(function(){
  // Labels (use \n for line breaks)
  const labels = [
    'Interim',
    'Stage 1',
    'Stage 2\n& Combined Stage 1–2',
    'Stage 3',
    'Stage 4'
  ];

  // CSS vars
  const cs = getComputedStyle(document.documentElement);
  const H         = +cs.getPropertyValue('--h') || 64;
  const TIP       = +cs.getPropertyValue('--tip') || 24;
  const TAIL      = +cs.getPropertyValue('--tail') || 14;
  const LEFT_CAP  = +cs.getPropertyValue('--left-cap') || 10;
  const BRAND_S   = cs.getPropertyValue('--brand-start').trim() || '#2e7df6';
  const BRAND_E   = cs.getPropertyValue('--brand-end').trim()   || '#7aa8ff';
  const HOVER     = cs.getPropertyValue('--hover').trim()       || '#eaf2ff';
  const TEXT_MUTED= cs.getPropertyValue('--text-muted').trim()  || '#5a6b82';

  const strip   = document.getElementById('chevrons');
  const canvas  = document.getElementById('navCanvas');
  const labelsEl= document.getElementById('labels');
  const panelsEl= document.getElementById('panels');

  let active = 0;
  let geom   = null; // segment geometry

  function sizeCanvas(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const Wcss = strip.clientWidth;
    canvas.width  = Math.floor(Wcss * dpr);
    canvas.height = Math.floor(H * dpr);
    canvas.style.width  = Wcss + 'px';
    canvas.style.height = H + 'px';
    const ctx = canvas.getContext('2d');
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
    return {ctx, W: Wcss, dpr};
  }

  function computeGeom(W){
    const N = labels.length;
    // With true left tip on first + right tips on all but last => N tips total.
    const baseW = Math.max(60, Math.floor((W - N * TIP) / N));
    const rects = [];
    for(let i=0;i<N;i++){
      const x0 = TIP + i * (baseW + TIP); // body left
      const x1 = x0 + baseW;              // body right
      rects.push([x0, x1]);
    }
    const segs = [];
    for(let i=0;i<N;i++){
      const [x0, x1] = rects[i];
      const isFirst = (i===0);
      const isLast  = (i===N-1);
      const TRx     = isLast ? x1 : (x1 - TIP);

      let poly = [];

      if(isFirst){
        // FIRST: start at TRUE LEFT APEX, then flat top, body, tip, flat bottom, back to apex
        poly = [
          [0, H/2],                 // left apex
          [LEFT_CAP, 0],            // top flat end
          [TRx, 0],                 // top-right of body
          ...(isLast ? [] : [[x1 + TIP, H/2]]), // right apex if not last
          [TRx, H],                 // bottom-right of body
          [LEFT_CAP, H]             // bottom flat end
          // closePath will return to [0, H/2]
        ];
      } else {
        // MIDDLE/LAST: forward chevron with slanted left tail
        poly = [
          [x0 - TAIL, H/2],         // left tail apex
          [x0, 0],                  // top-left body
          [TRx, 0],                 // top-right body
          ...(isLast ? [] : [[x1 + TIP, H/2]]), // right apex if not last
          [TRx, H],                 // bottom-right body
          [x0, H]                   // bottom-left body
          // closePath will return to [x0 - TAIL, H/2]
        ];
      }

      // Label center within BODY (exclude tips)
      const bodyLeft  = x0;
      const bodyRight = isLast ? x1 : (x1 - TIP);
      const cx = bodyLeft + (bodyRight - bodyLeft)/2;

      // Clickable horizontal extent (include tails/tips so it feels right)
      const btnLeft  = Math.max(0, isFirst ? 0 : (x0 - TAIL));
      const btnRight = Math.min(W, isLast ? x1 : (x1 + TIP));

      segs.push({ i, isFirst, isLast, x0, x1, TRx, poly, labelX: cx, btnLeft, btnRight });
    }
    return { baseW, rects, segs };
  }

  let hoverIndex = -1;

  function draw(){
    const {ctx, W} = sizeCanvas();
    geom = computeGeom(W);

    // background cleared; draw from right -> left (left tabs visually on top)
    for(let idx = geom.segs.length - 1; idx >= 0; idx--){
      const seg = geom.segs[idx];

      // Fill
      if(idx === active){
        const grad = ctx.createLinearGradient(seg.x0, 0, seg.TRx, 0);
        grad.addColorStop(0, BRAND_S);
        grad.addColorStop(1, BRAND_E);
        ctx.fillStyle = grad;
      } else {
        ctx.fillStyle = '#ffffff';
      }

      ctx.beginPath();
      const pts = seg.poly;
      ctx.moveTo(pts[0][0], pts[0][1]);
      for(let k=1;k<pts.length;k++){ ctx.lineTo(pts[k][0], pts[k][1]); }
      ctx.closePath();
      ctx.fill();

      // Hover overlay for non-active
      if(hoverIndex === idx && idx !== active){
        ctx.save();
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = HOVER;
        ctx.fill();
        ctx.restore();
      }
    }

    // Labels (on canvas only; buttons are aria-only to avoid duplication)
    ctx.font = '600 14px system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    for(const seg of geom.segs){
      const lines = String(labels[seg.i]).split('\n');
      ctx.fillStyle = (seg.i === active) ? '#ffffff' : TEXT_MUTED;
      if(lines.length === 1){
        ctx.fillText(lines[0], seg.labelX, H/2 + 1);
      } else {
        ctx.fillText(lines[0], seg.labelX, H/2 - 8);
        ctx.fillText(lines[1], seg.labelX, H/2 + 10);
      }
    }

    layoutButtons(W);
  }

  function layoutButtons(W){
    // Build aria-labeled transparent buttons (no visible text)
    const N = labels.length;
    if(labelsEl.childElementCount !== N){
      labelsEl.innerHTML = '';
      for(let i=0;i<N;i++){
        const btn = document.createElement('button');
        btn.className = 'tab';
        btn.id = 't' + i;
        btn.setAttribute('role','tab');
        btn.setAttribute('aria-label', labels[i].replace(/\n/g,' ')); // accessibility label
        btn.setAttribute('aria-selected', i===active ? 'true' : 'false');
        btn.setAttribute('tabindex', i===active ? '0' : '-1');

        btn.addEventListener('click', ()=> activate(i));
        btn.addEventListener('mouseenter', ()=> { hoverIndex = i; draw(); });
        btn.addEventListener('mouseleave', ()=> { hoverIndex = -1; draw(); });
        btn.addEventListener('keydown', (e)=>{
          if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); activate(i); }
          if(e.key === 'ArrowRight' || e.key === 'ArrowLeft'){
            e.preventDefault();
            const dir = e.key === 'ArrowRight' ? 1 : -1;
            const next = (active + dir + N) % N;
            activate(next);
          }
        });

        labelsEl.appendChild(btn);
      }
    }
    // Position + update state
    const tabs = Array.from(labelsEl.children);
    tabs.forEach((btn, i)=>{
      const seg = geom.segs[i];
      btn.style.left  = seg.btnLeft + 'px';
      btn.style.width = Math.max(0, seg.btnRight - seg.btnLeft) + 'px';
      btn.style.zIndex = String(1000 - i);     // leftmost above
      const on = i===active;
      btn.setAttribute('aria-selected', on ? 'true' : 'false');
      btn.setAttribute('tabindex', on ? '0' : '-1');
    });
  }

  function activate(i){
    if(i === active) return;
    active = i;
    // Panels
    const ps = panelsEl.querySelectorAll('.panel');
    ps.forEach((p, idx) => p.classList.toggle('active', idx===active));
    draw();
    // move focus to active button without scrolling
    const act = document.getElementById('t'+i);
    if(act) act.focus({preventScroll:true});
  }

  // First draw + resize handling
  draw();
  let raf = 0;
  window.addEventListener('resize', ()=>{
    cancelAnimationFrame(raf);
    raf = requestAnimationFrame(draw);
  });
})();
</script>
</body>
</html>
