<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chevron Tabs — Pure SVG Forward-Only</title>
<style>
  :root{
    /* Tweak these if you like */
    --tip-px: 24;   /* chevron point width in pixels */
    --radius: 10px;
    --stroke: 1;    /* border width in pixels */

    /* Local palette for this test page */
    --accent-start: #2e7df6;
    --accent-end:   #7aa8ff;
    --nav-bg:       #ffffff;
    --text-primary: #0b1f33;
    --text-secondary:#5a6b82;
    --brand-blue:   #2e7df6;
    --body-bg:      #f7f9fc;
  }

  html, body { margin:0; padding:0; background:var(--body-bg); color:var(--text-primary);
    font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
  .wrap { max-width: 1100px; margin: 24px auto; padding: 0 16px; }

  .tabs-box{
    background: var(--nav-bg);
    border: calc(var(--stroke) * 2px) solid var(--brand-blue);
    border-radius: var(--radius);
    overflow: hidden;
  }

  /* Panels */
  .panels{
    background: var(--body-bg);
    padding: 16px;
    border-top: 1px solid var(--brand-blue);
  }
  .panel{ display:none; }
  .panel.active{ display:block; }

  /* SVG focus handling: remove UA outline that shows as black bars */
  svg :focus { outline: none; }
  svg [tabindex]:focus { outline: none; }

  /* Optional: custom focus style (uncomment if you want visible keyboard focus)
  svg g.seg:focus-visible path{
    filter: drop-shadow(0 0 0.5px rgba(0,0,0,.35));
  } */

  .seg-text { pointer-events:none; font-weight:600; fill: var(--text-secondary); }
  .seg-text.active { fill:#fff; }
</style>
</head>
<body>
<div class="wrap">
  <h2>Road Safety Audit Stages (Pure SVG – Forward Only)</h2>

  <div id="chevronTabs" class="tabs-box" aria-label="RSA stages tabs">
    <!-- SVG injected here -->
    <div class="panels" id="panels">
      <section class="panel active"><h3>Interim Road Safety Audit</h3><p>Interim content…</p></section>
      <section class="panel"><h3>Stage 1 Road Safety Audit</h3><p>Stage 1 content…</p></section>
      <section class="panel"><h3>Stage 2 &amp; Combined Stage 1–2</h3><p>Stage 2 + Combined content…</p></section>
      <section class="panel"><h3>Stage 3 Road Safety Audit</h3><p>Stage 3 content…</p></section>
      <section class="panel"><h3>Stage 4 Road Safety Audit</h3><p>Stage 4 content…</p></section>
    </div>
  </div>
</div>

<script>
(function(){
  const labels = [
    'Interim',
    'Stage 1',
    'Stage 2\n& Combined Stage 1–2',
    'Stage 3',
    'Stage 4'
  ];

  const tipPx      = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--tip-px')) || 24;
  const strokePx   = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--stroke')) || 1;

  const host = document.getElementById('chevronTabs');
  const panelsEl = document.getElementById('panels');

  const svgNS = 'http://www.w3.org/2000/svg';
  const svg = document.createElementNS(svgNS, 'svg');
  svg.setAttribute('width', '100%');
  svg.setAttribute('height', '64');
  svg.setAttribute('viewBox', '0 0 100 64');
  svg.setAttribute('preserveAspectRatio', 'none');
  svg.style.display = 'block';

  // Gradient defs
  const defs = document.createElementNS(svgNS, 'defs');
  const grad = document.createElementNS(svgNS, 'linearGradient');
  grad.setAttribute('id', 'activeGrad');
  grad.setAttribute('x1', '0%'); grad.setAttribute('y1', '0%');
  grad.setAttribute('x2', '100%'); grad.setAttribute('y2', '0%');
  const stop1 = document.createElementNS(svgNS, 'stop'); stop1.setAttribute('offset','0%');  stop1.setAttribute('stop-color','var(--accent-start)');
  const stop2 = document.createElementNS(svgNS, 'stop'); stop2.setAttribute('offset','100%');stop2.setAttribute('stop-color','var(--accent-end)');
  grad.append(stop1, stop2);
  defs.appendChild(grad);
  svg.appendChild(defs);

  host.insertBefore(svg, panelsEl);

  let active = 0;

  function draw(){
    // Clear old segments (keep defs)
    while(svg.lastChild && svg.lastChild !== defs){ svg.removeChild(svg.lastChild); }

    const rect = svg.getBoundingClientRect();
    let W = Math.max(320, Math.floor(rect.width));
    // Snap to even width to keep .5 alignment crisp at various DPR
    if (W % 2) W -= 1;
    const H = 64;
    const N = labels.length;
    const stroke = strokePx;
    const half = stroke/2;

    svg.setAttribute('viewBox', `0 0 ${W} ${H}`);

    const segW = Math.floor(W / N);
    const tip = Math.round(tipPx);
    const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--brand-blue') || '#2e7df6';

    for(let i=0;i<N;i++){
      const x0 = i * segW;
      const x1 = (i === N-1) ? W : (i+1) * segW;

      const isFirst = (i === 0);
      const isLast  = (i === N-1);

      // ---- Forward-only chevron geometry (no left notch) ----
      // Points (clockwise):
      // TL: first => (x0, 0); middle/last => (x0 + tip, 0)
      // TR: last  => (x1, 0); others => (x1 - tip, 0)
      // TIP: not last => (x1, H/2)
      // BR: last  => (x1, H); others => (x1 - tip, H)
      // BL: all => (x0, H)
      const TLx = (isFirst ? x0 + half : x0 + tip + half), TLy = half;
      const TRx = (isLast  ? x1 - half : x1 - tip - half), TRy = half;
      const BRx = (isLast  ? x1 - half : x1 - tip - half), BRy = H - half;
      const BLx = x0 + half, BLy = H - half;
      const TIPx = x1 - half, TIPy = H/2;

      const d = [];
      d.push(`M ${TLx},${TLy}`);         // TL
      d.push(`L ${TRx},${TRy}`);         // TR
      if(!isLast){
        d.push(`L ${TIPx},${TIPy}`);     // right tip
        d.push(`L ${BRx},${BRy}`);       // BR (pre-tip)
      }else{
        d.push(`L ${BRx},${BRy}`);       // BR (flat)
      }
      d.push(`L ${BLx},${BLy}`);         // BL
      d.push('Z');

      // Group for interactions
      const g = document.createElementNS(svgNS, 'g');
      g.classList.add('seg');
      g.setAttribute('tabindex','0');      // focusable
      g.setAttribute('role','tab');
      g.setAttribute('aria-selected', i===active ? 'true' : 'false');
      g.dataset.index = i;
      g.style.outline = 'none';            // nuke UA outline (Chrome/Edge/Safari)

      // Shape
      const path = document.createElementNS(svgNS, 'path');
      path.setAttribute('d', d.join(' '));
      path.setAttribute('vector-effect', 'non-scaling-stroke');
      path.setAttribute('shape-rendering', 'geometricPrecision');
      path.setAttribute('stroke', borderColor.trim());
      path.setAttribute('stroke-width', String(stroke));
      path.setAttribute('fill', i===active ? 'url(#activeGrad)' : '#ffffff');

      // Label text (centered)
      const label = labels[i];
      const text = document.createElementNS(svgNS, 'text');
      text.setAttribute('x', String(x0 + (x1-x0)/2));
      text.setAttribute('y', String(H/2 + 5));
      text.setAttribute('text-anchor','middle');
      text.setAttribute('dominant-baseline','middle');
      text.setAttribute('font-size','14');
      text.setAttribute('font-weight','600');
      text.classList.add('seg-text');

      if(label.includes('\n')){
        const [ln1, ln2] = label.split('\n');
        const t1 = document.createElementNS(svgNS, 'tspan');
        t1.setAttribute('x', text.getAttribute('x'));
        t1.setAttribute('dy', '-0.4em'); t1.textContent = ln1;
        const t2 = document.createElementNS(svgNS, 'tspan');
        t2.setAttribute('x', text.getAttribute('x'));
        t2.setAttribute('dy', '1.2em'); t2.textContent = ln2;
        text.append(t1, t2);
      }else{
        text.textContent = label;
      }
      if(i===active){ text.classList.add('active'); }

      // Events
      g.addEventListener('mouseenter', () => { if(i!==active) path.setAttribute('fill', '#e6f0ff'); });
      g.addEventListener('mouseleave', () => { path.setAttribute('fill', i===active ? 'url(#activeGrad)' : '#ffffff'); });
      g.addEventListener('click', () => activate(i));
      g.addEventListener('keydown', (e) => {
        if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); activate(i); }
        if(e.key === 'ArrowRight' || e.key === 'ArrowLeft'){
          e.preventDefault();
          const dir = e.key === 'ArrowRight' ? 1 : -1;
          const next = (active + dir + labels.length) % labels.length;
          activate(next);
          const nextG = svg.querySelector(`g.seg[data-index="${next}"]`);
          if(nextG) nextG.focus();
        }
      });

      // Bigger hit target
      const hit = document.createElementNS(svgNS, 'rect');
      hit.setAttribute('x', x0);
      hit.setAttribute('y', 0);
      hit.setAttribute('width', x1-x0);
      hit.setAttribute('height', H);
      hit.setAttribute('fill', 'transparent');

      g.append(path, text, hit);
      svg.appendChild(g);
    }
  }

  function activate(idx){
    active = idx;
    svg.querySelectorAll('g.seg').forEach((g, i) => {
      const path = g.querySelector('path');
      const txt  = g.querySelector('text');
      g.setAttribute('aria-selected', i===active ? 'true' : 'false');
      path.setAttribute('fill', i===active ? 'url(#activeGrad)' : '#ffffff');
      txt.classList.toggle('active', i===active);
    });
    const panels = panelsEl.querySelectorAll('.panel');
    panels.forEach((p, i)=> p.classList.toggle('active', i===active));
  }

  // Initial draw and resize handling
  draw();
  activate(0);

  let rafId = 0;
  window.addEventListener('resize', () => {
    cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(() => { draw(); activate(active); });
  });
})();
</script>
</body>
</html>
