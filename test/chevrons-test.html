<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chevron Tabs — Forward Chevrons (Tail + Tip) v5</title>
<style>
  :root{
    /* Geometry (tweak as needed) */
    --tail-px: 14;  /* left slanted tail width in px (diagonal) */
    --tip-px:  24;  /* right arrow tip width in px */
    --stroke:  1;   /* border thickness in px */
    --radius:  10px;

    /* Local palette for this test page */
    --accent-start: #2e7df6;
    --accent-end:   #7aa8ff;
    --nav-bg:       #ffffff;
    --text-primary: #0b1f33;
    --text-secondary:#5a6b82;
    --brand-blue:   #2e7df6;
    --body-bg:      #f7f9fc;
  }

  html, body {
    margin:0; padding:0; background:var(--body-bg); color:var(--text-primary);
    font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  }
  .wrap { max-width: 1100px; margin: 24px auto; padding: 0 16px; }

  .tabs-box{
    background: var(--nav-bg);
    border: calc(var(--stroke) * 2px) solid var(--brand-blue);
    border-radius: var(--radius);
    overflow: hidden;
  }

  .panels{
    background: var(--body-bg);
    padding: 16px;
    border-top: 1px solid var(--brand-blue);
  }
  .panel{ display:none; }
  .panel.active{ display:block; }

  /* Remove UA focus bars on SVG elements */
  svg :focus { outline: none; }
  svg [tabindex]:focus { outline: none; }

  .seg-text { pointer-events: none; font-weight: 600; fill: var(--text-secondary); }
  .seg-text.active { fill: #fff; }
</style>
</head>
<body>
<div class="wrap">
  <h2>Road Safety Audit Stages (Forward Chevrons)</h2>

  <div id="chevronTabs" class="tabs-box" aria-label="RSA stages tabs">
    <!-- SVG strip injected here -->
    <div class="panels" id="panels">
      <section class="panel active"><h3>Interim Road Safety Audit</h3><p>Interim content…</p></section>
      <section class="panel"><h3>Stage 1 Road Safety Audit</h3><p>Stage 1 content…</p></section>
      <section class="panel"><h3>Stage 2 &amp; Combined Stage 1–2</h3><p>Stage 2 + Combined content…</p></section>
      <section class="panel"><h3>Stage 3 Road Safety Audit</h3><p>Stage 3 content…</p></section>
      <section class="panel"><h3>Stage 4 Road Safety Audit</h3><p>Stage 4 content…</p></section>
    </div>
  </div>
</div>

<script>
(function(){
  // Labels (use \n for a line break)
  const labels = [
    'Interim',
    'Stage 1',
    'Stage 2\n& Combined Stage 1–2',
    'Stage 3',
    'Stage 4'
  ];

  // Config from CSS vars
  const tipPx    = +getComputedStyle(document.documentElement).getPropertyValue('--tip-px')  || 24;
  const tailPx   = +getComputedStyle(document.documentElement).getPropertyValue('--tail-px') || 14;
  const strokePx = +getComputedStyle(document.documentElement).getPropertyValue('--stroke')  || 1;

  // Elements
  const host = document.getElementById('chevronTabs');
  const panelsEl = document.getElementById('panels');

  const svgNS = 'http://www.w3.org/2000/svg';
  const svg = document.createElementNS(svgNS, 'svg');
  svg.setAttribute('width', '100%');
  svg.setAttribute('height', '64');                     // strip height
  svg.setAttribute('viewBox', '0 0 100 64');            // will be reset on draw
  svg.setAttribute('preserveAspectRatio', 'none');
  svg.style.display = 'block';

  // Gradient defs
  const defs = document.createElementNS(svgNS, 'defs');
  const grad = document.createElementNS(svgNS, 'linearGradient');
  grad.setAttribute('id', 'activeGrad');
  grad.setAttribute('x1', '0%'); grad.setAttribute('y1', '0%');
  grad.setAttribute('x2', '100%'); grad.setAttribute('y2', '0%');
  const stop1 = document.createElementNS(svgNS, 'stop'); stop1.setAttribute('offset','0%');  stop1.setAttribute('stop-color','var(--accent-start)');
  const stop2 = document.createElementNS(svgNS, 'stop'); stop2.setAttribute('offset','100%');stop2.setAttribute('stop-color','var(--accent-end)');
  grad.append(stop1, stop2);
  defs.appendChild(grad);
  svg.appendChild(defs);

  host.insertBefore(svg, panelsEl);

  let active = 0;

  function draw(){
    // Clear old segments, keep defs
    while(svg.lastChild && svg.lastChild !== defs){ svg.removeChild(svg.lastChild); }

    const rect = svg.getBoundingClientRect();
    let W = Math.max(360, Math.floor(rect.width));
    if (W % 2) W -= 1; // even width -> crisp half-pixel stroke alignment
    const H = 64;
    const N = labels.length;
    const stroke = strokePx;
    const half = stroke / 2;

    svg.setAttribute('viewBox', `0 0 ${W} ${H}`);

    const tip = Math.round(tipPx);
    const tail = Math.round(tailPx);

    // Base rectangle widths so that total width remains W when tips overlap next tabs
    // We subtract the width of all tips (N-1) from W, then distribute evenly.
    const baseW = Math.max(40, Math.floor((W - tip * (N - 1)) / N));

    // Rectangle span for each tab i:
    // x0 = i * (baseW + tip); x1 = x0 + baseW
    const rects = [];
    for (let i=0; i<N; i++){
      const x0 = i * (baseW + tip);
      const x1 = x0 + baseW;
      rects.push([x0, x1]);
    }

    const borderColor = (getComputedStyle(document.documentElement).getPropertyValue('--brand-blue') || '#2e7df6').trim();

    // Draw RIGHT -> LEFT so each left tab sits on top of the next (covers any seam)
    for(let i=N-1; i>=0; i--){
      const [x0, x1] = rects[i];
      const isLast = (i === N-1);

      // ---- Forward chevron geometry (slanted tail + right tip) ----
      // TL: x0 + tail, 0
      // TR: (last ? x1 : x1 - tip), 0
      // TIP: (not last) x1 + tip, H/2
      // BR: (last ? x1 : x1 - tip), H
      // BL: x0, H
      // Close back to TL
      const TLx = x0 + tail + half, TLy = half;
      const TRx = (isLast ? x1 - half : x1 - tip - half), TRy = half;
      const BRx = (isLast ? x1 - half : x1 - tip - half), BRy = H - half;
      const BLx = x0 + half, BLy = H - half;
      const TIPx = x1 + (isLast ? 0 : tip) - half, TIPy = H/2;

      const d = [];
      d.push(`M ${TLx},${TLy}`);      // TL
      d.push(`L ${TRx},${TRy}`);      // TR
      if(!isLast){
        d.push(`L ${TIPx},${TIPy}`);  // Right tip
        d.push(`L ${BRx},${BRy}`);    // BR (return to body)
      }else{
        d.push(`L ${BRx},${BRy}`);    // BR (flat last)
      }
      d.push(`L ${BLx},${BLy}`);      // BL
      d.push('Z');

      // Group for interactivity
      const g = document.createElementNS(svgNS, 'g');
      g.classList.add('seg');
      g.setAttribute('tabindex','0');
      g.setAttribute('role','tab');
      g.setAttribute('aria-selected', i===active ? 'true' : 'false');
      g.dataset.index = i;
      g.style.outline = 'none';

      // Shape
      const shape = document.createElementNS(svgNS, 'path');
      shape.setAttribute('d', d.join(' '));
      shape.setAttribute('vector-effect', 'non-scaling-stroke');
      shape.setAttribute('shape-rendering', 'geometricPrecision');
      shape.setAttribute('stroke', borderColor);
      shape.setAttribute('stroke-width', String(stroke));
      shape.setAttribute('fill', i===active ? 'url(#activeGrad)' : '#ffffff');

      // Text (centered on the rectangular body, not counting the tip)
      const cx = x0 + tail + ( (x1 - (x0 + tail) - (isLast ? 0 : tip)) / 2 );
      const text = document.createElementNS(svgNS, 'text');
      text.setAttribute('x', String(cx));
      text.setAttribute('y', String(H/2 + 5));
      text.setAttribute('text-anchor','middle');
      text.setAttribute('dominant-baseline','middle');
      text.setAttribute('font-size','14');
      text.setAttribute('font-weight','600');
      text.classList.add('seg-text');

      const label = labels[i];
      if(label.includes('\n')){
        const [ln1, ln2] = label.split('\n');
        const t1 = document.createElementNS(svgNS, 'tspan');
        t1.setAttribute('x', String(cx));
        t1.setAttribute('dy', '-0.4em'); t1.textContent = ln1;
        const t2 = document.createElementNS(svgNS, 'tspan');
        t2.setAttribute('x', String(cx));
        t2.setAttribute('dy', '1.2em'); t2.textContent = ln2;
        text.append(t1, t2);
      }else{
        text.textContent = label;
      }
      if(i===active){ text.classList.add('active'); }

      // Events
      g.addEventListener('mouseenter', () => { if(i!==active) shape.setAttribute('fill', '#e6f0ff'); });
      g.addEventListener('mouseleave', () => { shape.setAttribute('fill', i===active ? 'url(#activeGrad)' : '#ffffff'); });
      g.addEventListener('click', () => activate(i));
      g.addEventListener('keydown', (e) => {
        if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); activate(i); }
        if(e.key === 'ArrowRight' || e.key === 'ArrowLeft'){
          e.preventDefault();
          const dir = e.key === 'ArrowRight' ? 1 : -1;
          const next = (active + dir + labels.length) % labels.length;
          activate(next);
          const nextG = svg.querySelector(`g.seg[data-index="${next}"]`);
          if(nextG) nextG.focus();
        }
      });

      // Larger hit area (include tip)
      const hit = document.createElementNS(svgNS, 'rect');
      hit.setAttribute('x', x0);
      hit.setAttribute('y', 0);
      hit.setAttribute('width', (x1 - x0) + (isLast ? 0 : tip));
      hit.setAttribute('height', H);
      hit.setAttribute('fill', 'transparent');

      g.append(shape, text, hit);
      svg.appendChild(g);
    }
  }

  function activate(idx){
    active = idx;
    svg.querySelectorAll('g.seg').forEach((g, i) => {
      const path = g.querySelector('path');
      const txt  = g.querySelector('text');
      g.setAttribute('aria-selected', i===active ? 'true' : 'false');
      path.setAttribute('fill', i===active ? 'url(#activeGrad)' : '#ffffff');
      txt.classList.toggle('active', i===active);
    });
    const panels = panelsEl.querySelectorAll('.panel');
    panels.forEach((p, i)=> p.classList.toggle('active', i===active));
  }

  // Initial draw + resize reflow
  draw();
  activate(0);
  let rafId = 0;
  window.addEventListener('resize', () => {
    cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(() => { draw(); activate(active); });
  });
})();
</script>
</body>
</html>
