<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chevron Tabs — Canvas (double-ended, seam-proof)</title>
<style>
  :root{
    --h: 64;          /* strip height (px, even recommended) */
    --tip: 24;        /* arrow tip width (px) */
    --text-muted: #5a6b82;
    --brand-start:#2e7df6; /* active gradient */
    --brand-end:  #7aa8ff;
    --hover:      #eaf2ff;
    --shell-bd:   #2e7df6;
    --shell-bg:   #ffffff;
    --page-bg:    #f7f9fc;
  }

  html,body{margin:0;padding:0;background:var(--page-bg);
    font:16px/1.5 system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif}
  .wrap{max-width:1100px;margin:24px auto;padding:0 16px}

  .tabs-shell{
    border:2px solid var(--shell-bd);
    border-radius:10px;
    background:var(--shell-bg);
  }

  /* Canvas strip (no borders ⇒ no hairlines) */
  .chevron-strip{ position:relative; height: calc(var(--h) * 1px); }
  .chevron-strip canvas{ display:block; width:100%; height:100%; }

  /* Transparent overlay buttons for click/keyboard only (no visible text) */
  .overlay{ position:absolute; inset:0; }
  .tab{
    position:absolute; top:0; height:100%;
    background:transparent; border:0; margin:0; padding:0;
    color:transparent; font-size:0; cursor:pointer; outline:none;
  }
  .tab:focus-visible{ outline:3px solid #94b8ff; outline-offset:2px; }

  .panels{ background:var(--page-bg); padding:16px; border-top:1px solid var(--shell-bd) }
  .panel{ display:none; }
  .panel.active{ display:block; }
</style>
</head>
<body>
<div class="wrap">
  <h2>Road Safety Audit Stages — Canvas chevrons (double-ended, no seams)</h2>

  <div class="tabs-shell" aria-label="RSA stages tabs">
    <div id="strip" class="chevron-strip" role="tablist">
      <canvas id="canvas"></canvas>
      <div id="overlay" class="overlay"></div>
    </div>

    <div id="panels" class="panels">
      <section class="panel active" role="tabpanel" aria-labelledby="t0"><h3>Interim Road Safety Audit</h3><p>Interim content…</p></section>
      <section class="panel" role="tabpanel" aria-labelledby="t1"><h3>Stage 1 Road Safety Audit</h3><p>Stage 1 content…</p></section>
      <section class="panel" role="tabpanel" aria-labelledby="t2"><h3>Stage 2 &amp; Combined Stage 1–2</h3><p>Stage 2 + Combined content…</p></section>
      <section class="panel" role="tabpanel" aria-labelledby="t3"><h3>Stage 3 Road Safety Audit</h3><p>Stage 3 content…</p></section>
      <section class="panel" role="tabpanel" aria-labelledby="t4"><h3>Stage 4 Road Safety Audit</h3><p>Stage 4 content…</p></section>
    </div>
  </div>
</div>

<script>
(function(){
  // Tabs (use \n for a line break in a label)
  const labels = [
    'Interim',
    'Stage 1',
    'Stage 2\n& Combined Stage 1–2',
    'Stage 3',
    'Stage 4'
  ];

  // CSS vars
  const css = getComputedStyle(document.documentElement);
  const H    = +css.getPropertyValue('--h')   || 64;
  const TIP  = +css.getPropertyValue('--tip') || 24;
  const BRAND_S = css.getPropertyValue('--brand-start').trim() || '#2e7df6';
  const BRAND_E = css.getPropertyValue('--brand-end').trim()   || '#7aa8ff';
  const HOVER   = css.getPropertyValue('--hover').trim()       || '#eaf2ff';
  const TEXT_M  = css.getPropertyValue('--text-muted').trim()  || '#5a6b82';

  const strip    = document.getElementById('strip');
  const canvas   = document.getElementById('canvas');
  const overlay  = document.getElementById('overlay');
  const panelsEl = document.getElementById('panels');

  let active = 0, hoverIndex = -1, geom = null;

  function sizeCanvas(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const Wcss = strip.clientWidth;
    canvas.width  = Math.floor(Wcss * dpr);
    canvas.height = Math.floor(H * dpr);
    canvas.style.width  = Wcss + 'px';
    canvas.style.height = H + 'px';
    const ctx = canvas.getContext('2d');
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
    return {ctx, W: Wcss, dpr};
  }

  // Core geometry: each middle segment is a TRUE double-ended arrow.
  // First: left + right tips. Last: left tip only.
  function computeGeom(W){
    const N = labels.length;
    // Base body width: distributing space; tips overlap neighbors.
    // We offset bodies by TIP so the first left apex is at x=0.
    const baseW = Math.max(60, Math.floor((W - N*TIP) / N));
    const segs = [];
    for(let i=0;i<N;i++){
      const S  = TIP + i*(baseW + TIP);  // body left (S)
      const E  = S + baseW;              // body right (E)
      const Lx = S - TIP;                // left apex x
      const Rx = E + TIP;                // right apex x
      const isFirst = (i === 0);
      const isLast  = (i === N-1);

      // Build polygon points (clockwise). No strokes, fills only. Small epsilon overlap.
      const eps = 0.01; // tiny overdraw to kill any AA gaps
      const TRx = isLast ? E        : (E - TIP);   // top-right body x
      const BRx = isLast ? E        : (E - TIP);   // bottom-right body x
      const TLx = S;                                // top-left body x
      const BLx = S;                                // bottom-left body x

      const poly = [];
      // Start from left tip apex (or left edge for first? We want a left tip on first too.)
      // All middles: left tip, body, right tip, back.
      if(isFirst){
        // FIRST: left tip apex at x=0, plus right tip if not last
        poly.push([0 - eps, H/2]);             // left apex (start)
        poly.push([TLx, 0]);                   // top-left body
        poly.push([TRx, 0]);                   // top-right body
        if(!isLast){ poly.push([Rx + eps, H/2]); } // right apex
        poly.push([BRx, H]);                   // bottom-right body
        poly.push([BLx, H]);                   // bottom-left body
        // close returns to left apex
      }else{
        // MIDDLE / LAST: left apex -> top-left -> top-right -> right apex? -> bottom-right -> bottom-left
        poly.push([Lx - eps, H/2]);            // left apex
        poly.push([TLx, 0]);                   // top-left
        poly.push([TRx, 0]);                   // top-right
        if(!isLast){ poly.push([Rx + eps, H/2]); } // right apex (omit for last)
        poly.push([BRx, H]);                   // bottom-right
        poly.push([BLx, H]);                   // bottom-left
      }

      // Label center (in body only; excludes right tip)
      const labelX = (TLx + TRx) / 2;

      // Click area: include the tip spans so the target feels right
      const btnLeft  = Math.max(0, isFirst ? 0    : (Lx));
      const btnRight = Math.min(W,  isLast  ? E   : (Rx));

      segs.push({i, isFirst, isLast, S, E, Lx, Rx, TRx, poly, labelX, btnLeft, btnRight});
    }
    return {segs};
  }

  function draw(){
    const {ctx, W} = sizeCanvas();
    geom = computeGeom(W);
    ctx.clearRect(0,0,W,H);

    // Paint right -> left so left segments sit on top in overlaps (no seams)
    for(let idx = geom.segs.length - 1; idx >= 0; idx--){
      const seg = geom.segs[idx];

      // Fill style
      if(idx === active){
        const grad = ctx.createLinearGradient(seg.S, 0, seg.TRx, 0);
        grad.addColorStop(0, BRAND_S);
        grad.addColorStop(1, BRAND_E);
        ctx.fillStyle = grad;
      } else {
        ctx.fillStyle = '#ffffff';
      }

      // Path
      ctx.beginPath();
      const pts = seg.poly;
      ctx.moveTo(pts[0][0], pts[0][1]);
      for(let k=1;k<pts.length;k++){ ctx.lineTo(pts[k][0], pts[k][1]); }
      ctx.closePath();
      ctx.fill();

      // Hover overlay
      if(hoverIndex === idx && idx !== active){
        ctx.save();
        ctx.fillStyle = HOVER;
        ctx.globalAlpha = 1.0;
        ctx.fill();
        ctx.restore();
      }
    }

    // Labels (canvas only; overlay buttons are aria-only)
    ctx.font = '600 14px system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    for(const seg of geom.segs){
      const lines = String(labels[seg.i]).split('\n');
      ctx.fillStyle = (seg.i === active) ? '#ffffff' : TEXT_M;
      if(lines.length === 1){
        ctx.fillText(lines[0], seg.labelX, H/2 + 1);
      }else{
        ctx.fillText(lines[0], seg.labelX, H/2 - 8);
        ctx.fillText(lines[1], seg.labelX, H/2 + 10);
      }
    }

    layoutButtons(W);
  }

  function layoutButtons(W){
    const N = labels.length;
    if(overlay.childElementCount !== N){
      overlay.innerHTML = '';
      for(let i=0;i<N;i++){
        const btn = document.createElement('button');
        btn.className = 'tab';
        btn.id = 't'+i;
        btn.setAttribute('role','tab');
        btn.setAttribute('aria-label', labels[i].replace(/\n/g,' '));
        btn.setAttribute('aria-selected', i===active ? 'true' : 'false');
        btn.setAttribute('tabindex', i===active ? '0' : '-1');

        btn.addEventListener('click', ()=> activate(i));
        btn.addEventListener('mouseenter', ()=> { hoverIndex = i; draw(); });
        btn.addEventListener('mouseleave', ()=> { hoverIndex = -1; draw(); });
        btn.addEventListener('keydown', (e)=>{
          if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); activate(i); }
          if(e.key === 'ArrowRight' || e.key === 'ArrowLeft'){
            e.preventDefault();
            const dir = e.key === 'ArrowRight' ? 1 : -1;
            const next = (active + dir + N) % N;
            activate(next);
          }
        });
        overlay.appendChild(btn);
      }
    }
    const tabs = Array.from(overlay.children);
    tabs.forEach((btn, i)=>{
      const seg = geom.segs[i];
      // Position the interactive area
      btn.style.left  = Math.max(0, seg.btnLeft) + 'px';
      btn.style.width = Math.max(0, seg.btnRight - seg.btnLeft) + 'px';
      // Stack so left-most sits above (covers overlaps)
      btn.style.zIndex = String(1000 - i);
      const on = i===active;
      btn.setAttribute('aria-selected', on ? 'true':'false');
      btn.setAttribute('tabindex', on ? '0':'-1');
    });
  }

  function activate(i){
    if(i === active) return;
    active = i;
    // Panels
    const ps = panelsEl.querySelectorAll('.panel');
    ps.forEach((p, idx)=> p.classList.toggle('active', idx===active));
    draw();
    const act = document.getElementById('t'+i);
    if(act) act.focus({preventScroll:true});
  }

  // Initial draw + resize
  draw();
  let raf=0;
  window.addEventListener('resize', ()=>{
    cancelAnimationFrame(raf);
    raf = requestAnimationFrame(draw);
  });
})();
</script>
</body>
</html>
